package design_pattern.singleton;

public class Singleton {
    private static volatile Singleton instance;
//    private String message;

    private Singleton() {
//        this.message=message;
    }

    // Nothing in this code prevents two threads from accessing this piece of code at the same time.
/*    public static Singleton getInstance(String message) {
        if (instance == null) {
            instance = new Singleton(message);
        }
        return instance;
    }*/

    // But now, even if the instance was created, every thread will wait for the lock to be released before accessing the instance.
    // This can be solved by applying the double-check locking idiom.

/*    public static Singleton getInstance(String message) {
        synchronized (Singleton.class) {
            if (instance == null) {
                instance = new Singleton(message);
            }
        }
        return instance;
    }*/

    // Here limiting synchronization to the rare case of constructing a new instance of this field.
    // skipping synchronization when retrieving an already-created instance.
    /* Here the problem is due to the semantics of some programming languages the code generated by the compiler is allowed
        to update the shared variable stored in the memory to reference partially constructed object. So before first
        thread finishes the whole initialization processes the shared variable or the singleton in our case can be immediately
        updated the memory and other threads of our application will consider it as initialized and use it.
        in our example while thread one is constructing this object, thread two may try to retrieve of the first
        if-statement we just added thread two will not wait for thread one to finish the initialization and will use
        the instance referenced even if it is partially constructed object. Causing our application to crash.
        To avoid such scenarios all we have to do is set the singleton instance we have to be volatile.
        This keyword ensures that multiple threads will be able to handle the singleton instance correctly..

    */

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }



}

